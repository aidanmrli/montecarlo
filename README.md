# montecarlo
A modular high-level library for running high-dimensional Metropolis algorithms across a variety of scaling and tempering conditions.
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

## Overview
We offer implementations of the following:
- Random-walk Metropolis algorithms with or without parallel tempering. 
- Various target distributions with densities that are used for experimentation. This includes the multivariate normal and various multimodal distributions.
- Visualizations: we have traceplots and histograms for individual simulations, as well as line plots showing the overall trends of ESJD with acceptance rate or proposal variance.
- Experiment suite to run individual simulations, or many simulations with a changed value (such as the scaling), or parallel tempering algorithms.
- Clean architecture adhering to SOLID principles so that this repository can be extended easily with a plug-and-play system for algorithms, target distributions, and proposal distributions in experiments.

## To run a single experiment:
Run experiment.py (in the root directory). Adjust the simulation arguments as necessary before the experiment: 
- change the dimension of the target and proposal distributions
- proposal variance (sigma)
- number of iterations
- choice of algorithm
- target distribution
- symmetry of the proposal distribution (Metropolis vs Metropolis-Hastings)
- numpy seed

The MCMCSimulation class can generate visualizations such as a histogram in a single dimension, and the traceplot of the Markov chain in a single dimension (or all dimensions).

## To run many experiments:
Maybe you might want to see how acceptance rate and ESJD change as you vary a single variable, such as the scaling of the proposal, or the temperature spacing between chains in a parallel tempering algorithm.

Run experiment_many.py or experiment_pt.py in the root directory. Adjust the simulation arguments as necessary before the experiment: 
- change the dimension of the target and proposal distributions
- proposal variance (sigma)
- number of iterations per experiment
- choice of algorithm
- target distribution
- symmetry of the proposal distribution (Metropolis vs Metropolis-Hastings)
- numpy seed

Both of these files average the results over multiple data seeds to reduce the effects of the random numbers generated by the computer.

experiment_many.py plots line graphs for ESJD vs acceptance rate, acceptance rate vs proposal variance, and ESJD vs proposal variance.
experiment_pt.py plots line graphs for ESJD vs the swap acceptance rate of the actual ran algorithms

## Directory Structure
General classes with their attributes and methods are in the main folder. 
- MCMCSimulation is a class for running a single MCMC simulation for generating samples from a target distribution and visualizing the various metrics and results.
- TargetDistribution is a general interface for specifying the methods of a target distribution. The implementations of this class in the target_distributions folder implement these methods, such as the density.
- MHAlgorithm is a general interface for a Metropolis-Hastings algorithm for sampling for a target distribution.  The implementations of this class in the algorithms folder implement these methods, such as calculating the (log) acceptance probability.

Algorithm implementations are in the algorithms folder. Likewise, target distribution implementations are in the target_distributions folder. These implementations _inherit_ the methods and attributes defined by their parents, allowing for a greater degree of consistency between different implementations.
