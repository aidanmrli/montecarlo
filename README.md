# montecarlo
A modular high-level library for running high-dimensional Metropolis algorithms across a variety of scaling and tempering conditions.
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

## Overview
We offer implementations of the following:
- Random-walk Metropolis algorithms with or without parallel tempering. 
- Various target distributions with densities that are used for experimentation. This includes the multivariate normal and various multimodal distributions.
- Visualizations: we have traceplots and histograms for individual simulations, as well as line plots showing the overall trends of ESJD with acceptance rate or proposal variance.
- Experiment suite to run individual simulations, or many simulations with a changed value (such as the scaling), or parallel tempering algorithms.
- Clean architecture adhering to SOLID principles so that this repository can be extended easily with a plug-and-play system for algorithms, target distributions, and proposal distributions in experiments.

## Getting Started
### Installation
To download the repository, navigate to a directory in your terminal and run `https://github.com/aidanmrli/montecarlo.git`.
Once you have this repository locally, navigate into the repository. 
While you are in the root directory, run `pip install -r requirements.txt`. Python comes with pip automatically installed, but if you have any issues please go to `https://pip.pypa.io/en/stable/installation/`.

```bash
git clone https://github.com/aidanmrli/montecarlo.git
cd montecarlo
pip install -r requirements.txt
```

### To run a single experiment:
Run experiment.py (in the root directory). Adjust the simulation arguments in experiment.py as necessary before the experiment.

The MCMCSimulation class can generate visualizations such as a histogram in a single dimension, and the traceplot of the Markov chain in a single dimension (or all dimensions).

### To run many experiments:
Maybe you might want to see how acceptance rate and ESJD change as you vary a single variable, such as the scaling of the proposal, or the temperature spacing between chains in a parallel tempering algorithm.

Run experiment_many.py or experiment_pt.py in the root directory. Adjust the simulation arguments in these files as necessary before the experiment.

Both of these files average the results over multiple data seeds to reduce the effects of the random numbers generated by the computer.

experiment_many.py plots line graphs for ESJD vs acceptance rate, acceptance rate vs proposal variance, and ESJD vs proposal variance.
experiment_pt.py plots line graphs for ESJD vs the swap acceptance rate of the actual ran algorithms

### To Run Multivariate Gaussian Examples with IID Components:
(Section 3.1.1 in the report) If without scaling factors: Run Metropolis Algorithm.py in the main folder. It contains running the Metropolis algorithm, generating the trace plot, and displaying the relation between ESJD and acceptance rate with various proposal variances. An example experiment is provided at the end, where you can modify the values, comment or uncomment code sections to obtain the plots and results.

(Section 3.1.2 in the report) If with scaling factors: Run factor_metropolis_algorithm.py in the main folder. It involves running the Metropolis algorithm, defining the scaling factors, generating the trace plot, and displaying the relation between ESJD and acceptance rate with various proposal variances. An example experiment is provided at the end, and you're welcome to adjust the initial values for further experimentation.

### To Run Multivariate Gaussian Examples with NON-IID Components:
(Section 3.2.1) If non-independent case: Run dependent_Multivariate_Gaussian_Case.py in the main folder. There are three different cases regarding the proposal distribution. The file includes guidance, explanations, and comments to help you run various experiments with different proposal distributions.

(Section 3.2.2) If non-identically distributed case: Run converge_target_density_case.py in the main folder. Similar to the above procedure, it includes an example of experiments at the end.

### To Run Double Exponential Proposal Distribution Examples
(Section 4.2) Run double_exponential_proposal_distribution_example.py in the main folder. This file includes running the Metropolis algorithm, generating the trace plot and histogram, and the relationship between ESJD and acceptance rate. You can modify the values of the example at the end.

### To Run Uniform Proposal Distribution Examples
(Section 4.3) Run uniform_proposal_distribution.py in the main folder. This file includes running the Metropolis algorithm, generating the trace plot and histogram, and the relationship between ESJD and acceptance rate. You can modify the values of the example at the end.

## Directory Structure
General classes with their attributes and methods are in the main folder. 
- MCMCSimulation is a class for running a single MCMC simulation for generating samples from a target distribution and visualizing the various metrics and results.
- TargetDistribution is a general interface for specifying the methods of a target distribution. The implementations of this class in the target_distributions folder implement these methods, such as the density.
- MHAlgorithm is a general interface for a Metropolis-Hastings algorithm for sampling for a target distribution.  The implementations of this class in the algorithms folder implement these methods, such as calculating the (log) acceptance probability.

Algorithm implementations are in the algorithms folder. Likewise, target distribution implementations are in the target_distributions folder. These implementations _inherit_ the methods and attributes defined by their parents, allowing for a greater degree of consistency between different implementations.

## License
This repository is MIT licensed. See the LICENSE file in the root directory.
