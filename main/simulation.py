import numpy as np
import matplotlib.pyplot as plt
from .metropolis import MHAlgorithm
from algorithms import *
from typing import Optional, Callable

class MCMCSimulation:
    def __init__(self, 
                 dim: int, 
                 sigma: float, 
                 num_iterations: int = 1000, 
                 algorithm: MHAlgorithm = RandomWalkMH,
                 target_dist: Callable = None,
                 symmetric: bool = True,
                 seed: Optional[int] = None):
        self.num_iterations = num_iterations
        self.algorithm = algorithm(dim, sigma, target_dist, symmetric)
        if seed:
            np.random.seed(seed)
    
    def reset(self):
        """Reset the simulation to the initial state."""
        self.algorithm.reset()

    def has_run(self):
        """Return whether the algorithm has been run."""
        return len(self.algorithm.chain) > 1

    def generate_samples(self):
        if self.has_run():
            raise ValueError("Please reset the algorithm before running it again.")
        for _ in range(self.num_iterations):
            self.algorithm.step()
        return self.algorithm.chain
    
    def acceptance_rate(self):
        """Return the acceptance rate of the algorithm."""
        if not self.has_run():
            raise ValueError("The algorithm has not been run yet.")
        return self.algorithm.acceptance_rate

    def expected_squared_jump_distance(self):
        """Calculate the expected squared jump distance for the 
        last n elements of the Markov chain. 
        Args:
            n (int): The number of steps to take in the chain.
        Returns:
            float: The expected squared jump distance.
        """
        if not self.has_run():
            raise ValueError("The algorithm has not been run yet.")
        chain = np.array(self.algorithm.chain)
        squared_jumps = np.sum((chain[1:] - chain[:-1]) ** 2, axis=1)
        return np.mean(squared_jumps)

    def traceplot(self):
        """Visualize the traceplot of the Markov chain.
        The traceplot plots the values of the parameters 
        against the iteration number in the Markov chain.
        """
        if not self.has_run():
            raise ValueError("The algorithm has not been run yet.")
        
        chain = np.array(self.algorithm.chain)
        for i in range(self.algorithm.dim):
            plt.plot(chain[:, i], label=f"Dimension {i + 1}", alpha=0.7, lw=0.5)

        plt.xlabel('Iteration')
        plt.ylabel('Value')
        plt.legend()
        plt.show()

    
    def autocorrelation_plot(self):
        """Visualize the autocorrelation of the Markov chain.
        """
        if not self.has_run():
            raise ValueError("The algorithm has not been run yet.")
        chain = np.array(self.algorithm.chain)
        autocorr = np.zeros(self.algorithm.dim)
        for i in range(self.algorithm.dim):
            autocorr[i] = np.correlate(chain[:, i] - np.mean(chain[:, i]), chain[:, i] - np.mean(chain[:, i]), mode='full')[chain.shape[0] - 1]
        
        plt.stem(range(len(autocorr)), autocorr)
        plt.xlabel('Lag')
        plt.ylabel('Autocorrelation')
        plt.show()

    def samples_histogram(self, target_density, num_bins=50):
        """Plot a histogram of the samples overlaid with the target density.
        Use for low-dimensional target distributions to ensure the correctness of samples.

        Args:
            samples (ndarray): The samples generated by the Markov chain.
            target_density (callable): The target density function.
            num_bins (int): The number of bins in the histogram. Default is 50.
        """
        # Generate histogram of samples
        samples = np.array(self.algorithm.chain)
        plt.hist(samples, bins=num_bins, density=True, alpha=0.5, label='Samples')

        # Generate values for plotting the target density
        x = np.linspace(np.min(samples), np.max(samples), 1000)
        y = target_density()

        plt.plot(x, y, color='red', linestyle='--', linewidth=2, label='Target Density')
        plt.xlabel('Value')
        plt.ylabel('Density')
        plt.legend()
        plt.show()
